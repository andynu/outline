# Architecture: Desktop App + Thin Server Split

## Overview

A hybrid architecture where a full-featured Tauri desktop app handles the lion's share of editing, while a thin server provides calendar feeds and mobile capture. Both read/write to a shared file-based data format synced via Dropbox/Nextcloud/Syncthing.

```
┌─────────────────────────────────────────────────────────────────┐
│                     SHARED DATA LAYER                           │
│                                                                 │
│         JSONL files (source of truth, human-readable)          │
│                           +                                     │
│         SQLite cache (local to each machine, fast queries)     │
│                                                                 │
│              ↕ Synced via Dropbox/Nextcloud/Syncthing ↕        │
└─────────────────────────────────────────────────────────────────┘
         │                                       │
         ▼                                       ▼
┌─────────────────────┐               ┌─────────────────────────┐
│   TAURI DESKTOP     │               │     THIN SERVER         │
│   (Heavy Client)    │               │     (Light Server)      │
└─────────────────────┘               └─────────────────────────┘
```

---

## Tauri Desktop App (Heavy Client)

### Responsibilities

**Full CRUD Operations**
- Create, edit, delete, move nodes
- All document management
- Mirror creation and resolution
- Link management and backlink indexing

**Rich Editing Experience**
- Keyboard-first navigation (all shortcuts from spec)
- Zoom/hoist into any node
- Collapse/expand
- Drag-and-drop reorganization
- Markdown formatting with live preview
- Date picker and natural language date parsing

**Local Processing**
- Full-text search indexing
- Tag extraction and indexing
- Backlink graph maintenance
- SQLite cache rebuilding from JSONL

**Offline-First**
- Works entirely offline
- Writes to JSONL immediately
- Sync happens when Dropbox/etc catches up

### Tech Stack

```
┌────────────────────────────────────────┐
│            Tauri Shell                 │
│  (Rust: file I/O, SQLite, JSONL sync)  │
├────────────────────────────────────────┤
│           Frontend (WebView)           │
│  (TypeScript + Svelte/Solid/React)     │
│                                        │
│  • Tree rendering (virtualized)        │
│  • Keyboard handling                   │
│  • Markdown editor                     │
│  • Command palette                     │
└────────────────────────────────────────┘
```

**Why Tauri over Electron:**
- Smaller binary (~10MB vs ~150MB)
- Lower memory footprint
- Rust backend handles file I/O safely
- No bundled Chromium (uses system webview)

### Data Flow

```
User types → Frontend state → IPC to Rust backend
                                    │
                    ┌───────────────┼───────────────┐
                    ▼               ▼               ▼
              Update SQLite   Append JSONL   Update indexes
              (fast queries)  (source of     (search, links)
                              truth)
```

---

## Thin Server (Light Server)

### Responsibilities

**Calendar Feed (static .ics)**
- `feed.ics` generated by desktop app on save
- Served as static file by nginx
- Optional: multiple feeds (e.g., `feed-work.ics`, `feed-personal.ics`) for tag filtering
- Syncs to server via Nextcloud, always fresh after desktop save

**Mobile Capture (write to inbox only)**
- `GET /capture` — simple HTML form
- `POST /capture` — append to inbox.jsonl
- Optional: API endpoint `POST /api/inbox` for shortcuts/automation

**Read-Only Browse (static HTML)**
- Static HTML pages generated by desktop app on save
- Simple tree view for reference
- No editing, no drag-drop, no complex interactions
- Purpose: "What was that thing?" from phone
- Served directly by nginx (no app runtime needed)

**Health/Status (optional, in capture app)**
- `GET /health` — is the capture app up, can it write to inbox?

### What It Explicitly Does NOT Do

- Full node editing (use desktop)
- Node moving/reorganization
- Mirror creation
- Conflict resolution
- User authentication beyond optional API key
- Multi-user anything

### Tech Stack

**Hybrid approach: Static exports + minimal Ruby capture app**

```
┌─────────────────────────────────────────────────────────────────┐
│                     STATIC EXPORTS                               │
│         (Generated by desktop app on save)                       │
├─────────────────────────────────────────────────────────────────┤
│  • feed.ics — calendar feed, served by nginx                     │
│  • Rendered HTML outlines — read-only browse view                │
│  • fswatch/cron copies to web-accessible location                │
└─────────────────────────────────────────────────────────────────┘
                              +
┌─────────────────────────────────────────────────────────────────┐
│                 MINIMAL RUBY APP (Sinatra/Roda)                  │
│                    (Handles capture only)                        │
├─────────────────────────────────────────────────────────────────┤
│  • GET /capture — simple HTML form                               │
│  • POST /capture — append to inbox.jsonl                         │
│  • POST /api/inbox — for shortcuts/automation                    │
│  • SQLite3 gem (if needed for queries)                           │
│  • ERB templates                                                 │
└─────────────────────────────────────────────────────────────────┘
```

Why this split:
- Calendar and browse are read-only → static files are simplest
- Only capture needs a runtime → minimal Ruby app
- Fast to develop, familiar stack

### Deployment

Runs on colo host (same machine as Nextcloud).

```
Colo Server
├── Nextcloud (already running, handles file sync)
├── nginx (serves static exports: .ics, HTML browse)
└── Ruby capture app (Sinatra/Roda, minimal)

Data access:
├── Static exports land in web-accessible directory via sync
├── Capture app writes to inbox.jsonl in synced folder
└── Nextcloud syncs inbox back to desktop
```

Potential Nextcloud integration:
- Files already synced via Nextcloud → static exports just appear
- Could potentially use Nextcloud's CalDAV if needed later
- Authentication could piggyback on Nextcloud if desired

---

## Sync Coordination

### Write Separation (Conflict Avoidance)

| Operation | Desktop | Server |
|-----------|---------|--------|
| Create/edit/delete nodes | ✅ | ❌ |
| Move nodes | ✅ | ❌ |
| Create mirrors | ✅ | ❌ |
| Append to inbox | ✅ | ✅ (capture app) |
| Read anything | ✅ | ✅ (static HTML) |
| Generate calendar/browse | ✅ (on save) | ❌ (serves static) |

By limiting server writes to inbox-only appends, we avoid conflicts entirely.

### Inbox Flow

```
Phone: "Remember to call dentist"
         │
         ▼
Server: POST /capture
         │
         ▼
inbox.jsonl: {"id":"uuid","content":"Remember to call dentist","captured_at":"..."}
         │
         ▼ (Dropbox syncs)
         │
Desktop: Shows "3 items in inbox" badge
         │
         ▼ (User processes inbox)
         │
Moved to proper location in main JSONL, removed from inbox
```

### Calendar Feed Freshness

Desktop regenerates `feed.ics` as part of save → synced to server via Nextcloud → always fresh after edits. No server-side regeneration needed.

---

## What This Architecture Optimizes For

**Optimizes for:**
- Single-user, self-hosted
- Desktop as primary editing environment
- Mobile as capture-only
- File-based sync (no custom sync protocol)
- Human-readable archival format
- Simplicity over features on server side

**Trades away:**
- Real-time collaboration
- Full mobile editing
- Seamless multi-device editing (must wait for sync)
- Server-side search (desktop only)

---

## Decisions

1. **Server writes beyond inbox?** ✅ **No — inbox capture only**
   - Mobile is capture-only; all editing happens on desktop
   - Avoids conflict handling complexity

2. **Authentication:** ✅ **Basic auth on `/outline/*`**
   - Single basic auth rule simplifies nginx config
   - Calendar endpoints use token-in-URL (no auth header)

3. **Calendar subscription auth:** ✅ **Token in URL**
   - `/calendar/{token}/feed.ics` where token is unguessable UUID
   - Works with Google Calendar (doesn't support auth headers)
   - Rotate token if leaked
